#include "type.h"
#include <led_display.h>
#include "freemono.h" // Include the FreeMono font
#include "font_test.h" // Include the test font



// Font data arrays
static const uint8_t font5x7[] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00,// (space)
	0x00, 0x00, 0x5F, 0x00, 0x00,// !
	0x00, 0x07, 0x00, 0x07, 0x00,// "
	0x14, 0x7F, 0x14, 0x7F, 0x14,// #
	0x24, 0x2A, 0x7F, 0x2A, 0x12,// $
	0x23, 0x13, 0x08, 0x64, 0x62,// %
	0x36, 0x49, 0x55, 0x22, 0x50,// &
	0x00, 0x05, 0x03, 0x00, 0x00,// '
	0x00, 0x1C, 0x22, 0x41, 0x00,// (
	0x00, 0x41, 0x22, 0x1C, 0x00,// )
	0x08, 0x2A, 0x1C, 0x2A, 0x08,// *
	0x08, 0x08, 0x3E, 0x08, 0x08,// +
	0x00, 0x50, 0x30, 0x00, 0x00,// ,
	0x08, 0x08, 0x08, 0x08, 0x08,// -
	0x00, 0x60, 0x60, 0x00, 0x00,// .
	0x20, 0x10, 0x08, 0x04, 0x02,// /
	0x3E, 0x51, 0x49, 0x45, 0x3E,// 0
	0x00, 0x42, 0x7F, 0x40, 0x00,// 1
	0x42, 0x61, 0x51, 0x49, 0x46,// 2
	0x21, 0x41, 0x45, 0x4B, 0x31,// 3
	0x18, 0x14, 0x12, 0x7F, 0x10,// 4
	0x27, 0x45, 0x45, 0x45, 0x39,// 5
	0x3C, 0x4A, 0x49, 0x49, 0x30,// 6
	0x01, 0x71, 0x09, 0x05, 0x03,// 7
	0x36, 0x49, 0x49, 0x49, 0x36,// 8
	0x06, 0x49, 0x49, 0x29, 0x1E,// 9
	0x00, 0x36, 0x36, 0x00, 0x00,// :
	0x00, 0x56, 0x36, 0x00, 0x00,// ;
	0x00, 0x08, 0x14, 0x22, 0x41,// <
	0x14, 0x14, 0x14, 0x14, 0x14,// =
	0x41, 0x22, 0x14, 0x08, 0x00,// >
	0x02, 0x01, 0x51, 0x09, 0x06,// ?
	0x32, 0x49, 0x79, 0x41, 0x3E,// @
	0x7E, 0x11, 0x11, 0x11, 0x7E,// A
	0x7F, 0x49, 0x49, 0x49, 0x36,// B
	0x3E, 0x41, 0x41, 0x41, 0x22,// C
	0x7F, 0x41, 0x41, 0x22, 0x1C,// D
	0x7F, 0x49, 0x49, 0x49, 0x41,// E
	0x7F, 0x09, 0x09, 0x01, 0x01,// F
	0x3E, 0x41, 0x41, 0x51, 0x32,// G
	0x7F, 0x08, 0x08, 0x08, 0x7F,// H
	0x00, 0x41, 0x7F, 0x41, 0x00,// I
	0x20, 0x40, 0x41, 0x3F, 0x01,// J
	0x7F, 0x08, 0x14, 0x22, 0x41,// K
	0x7F, 0x40, 0x40, 0x40, 0x40,// L
	0x7F, 0x02, 0x04, 0x02, 0x7F,// M
	0x7F, 0x04, 0x08, 0x10, 0x7F,// N
	0x3E, 0x41, 0x41, 0x41, 0x3E,// O
	0x7F, 0x09, 0x09, 0x09, 0x06,// P
	0x3E, 0x41, 0x51, 0x21, 0x5E,// Q
	0x7F, 0x09, 0x19, 0x29, 0x46,// R
	0x46, 0x49, 0x49, 0x49, 0x31,// S
	0x01, 0x01, 0x7F, 0x01, 0x01,// T
	0x3F, 0x40, 0x40, 0x40, 0x3F,// U
	0x1F, 0x20, 0x40, 0x20, 0x1F,// V
	0x7F, 0x20, 0x18, 0x20, 0x7F,// W
	0x63, 0x14, 0x08, 0x14, 0x63,// X
	0x03, 0x04, 0x78, 0x04, 0x03,// Y
	0x61, 0x51, 0x49, 0x45, 0x43,// Z
	0x00, 0x00, 0x7F, 0x41, 0x41,// [
	0x02, 0x04, 0x08, 0x10, 0x20,// "\"
	0x41, 0x41, 0x7F, 0x00, 0x00,// ]
	0x04, 0x02, 0x01, 0x02, 0x04,// ^
	0x40, 0x40, 0x40, 0x40, 0x40,// _
	0x00, 0x01, 0x02, 0x04, 0x00,// `
	0x20, 0x54, 0x54, 0x54, 0x78,// a
	0x7F, 0x48, 0x44, 0x44, 0x38,// b
	0x38, 0x44, 0x44, 0x44, 0x20,// c
	0x38, 0x44, 0x44, 0x48, 0x7F,// d
	0x38, 0x54, 0x54, 0x54, 0x18,// e
	0x08, 0x7E, 0x09, 0x01, 0x02,// f
	0x08, 0x14, 0x54, 0x54, 0x3C,// g
	0x7F, 0x08, 0x04, 0x04, 0x78,// h
	0x00, 0x44, 0x7D, 0x40, 0x00,// i
	0x20, 0x40, 0x44, 0x3D, 0x00,// j
	0x00, 0x7F, 0x10, 0x28, 0x44,// k
	0x00, 0x41, 0x7F, 0x40, 0x00,// l
	0x7C, 0x04, 0x18, 0x04, 0x78,// m
	0x7C, 0x08, 0x04, 0x04, 0x78,// n
	0x38, 0x44, 0x44, 0x44, 0x38,// o
	0x7C, 0x14, 0x14, 0x14, 0x08,// p
	0x08, 0x14, 0x14, 0x18, 0x7C,// q
	0x7C, 0x08, 0x04, 0x04, 0x08,// r
	0x48, 0x54, 0x54, 0x54, 0x20,// s
	0x04, 0x3F, 0x44, 0x40, 0x20,// t
	0x3C, 0x40, 0x40, 0x20, 0x7C,// u
	0x1C, 0x20, 0x40, 0x20, 0x1C,// v
	0x3C, 0x40, 0x30, 0x40, 0x3C,// w
	0x44, 0x28, 0x10, 0x28, 0x44,// x
	0x0C, 0x50, 0x50, 0x50, 0x3C,// y
	0x44, 0x64, 0x54, 0x4C, 0x44,// z
	0x00, 0x08, 0x36, 0x41, 0x00,// {
	0x00, 0x00, 0x7F, 0x00, 0x00,// |
	0x00, 0x41, 0x36, 0x08, 0x00,// }
	0x08, 0x08, 0x2A, 0x1C, 0x08,// ->
	0x08, 0x1C, 0x2A, 0x08, 0x08 // <-   
};



static const uint8_t font8x8[] PROGMEM = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x20, space
    0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00,   // 0x21, !
    0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x22, "
    0x6C, 0x6C, 0xFE, 0x6C, 0xFE, 0x6C, 0x6C, 0x00,   // 0x23, #
    0x18, 0x3E, 0x60, 0x3C, 0x06, 0x7C, 0x18, 0x00,   // 0x24, $
    0x00, 0x63, 0x66, 0x0C, 0x18, 0x33, 0x63, 0x00,   // 0x25, %
    0x1C, 0x36, 0x1C, 0x3B, 0x6E, 0x66, 0x3B, 0x00,   // 0x26, &
    0x0C, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x27, '
    0x0C, 0x18, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00,   // 0x28, (
    0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00,   // 0x29, )
    0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00,   // 0x2A, *
    0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00,   // 0x2B, +
    0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30,   // 0x2C, ,
    0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00,   // 0x2D, -
    0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00,   // 0x2E, .
    0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x40, 0x00,   // 0x2F, /
    0x3E, 0x63, 0x73, 0x7B, 0x6F, 0x67, 0x3E, 0x00,   // 0x30, 0
    0x18, 0x38, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00,   // 0x31, 1
    0x3C, 0x66, 0x06, 0x0C, 0x18, 0x30, 0x7E, 0x00,   // 0x32, 2
    0x3C, 0x66, 0x06, 0x1C, 0x06, 0x66, 0x3C, 0x00,   // 0x33, 3
    0x06, 0x0E, 0x1E, 0x36, 0x66, 0x7F, 0x06, 0x00,   // 0x34, 4
    0x7E, 0x60, 0x7C, 0x06, 0x06, 0x66, 0x3C, 0x00,   // 0x35, 5
    0x3C, 0x66, 0x60, 0x7C, 0x66, 0x66, 0x3C, 0x00,   // 0x36, 6
    0x7E, 0x66, 0x0C, 0x18, 0x18, 0x18, 0x18, 0x00,   // 0x37, 7
    0x3C, 0x66, 0x66, 0x3C, 0x66, 0x66, 0x3C, 0x00,   // 0x38, 8
    0x3C, 0x66, 0x66, 0x3E, 0x06, 0x66, 0x3C, 0x00,   // 0x39, 9
    0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x00,   // 0x3A, :
    0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x30,   // 0x3B, ;
    0x06, 0x0C, 0x18, 0x30, 0x18, 0x0C, 0x06, 0x00,   // 0x3C, <
    0x00, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x00, 0x00,   // 0x3D, =
    0x60, 0x30, 0x18, 0x0C, 0x18, 0x30, 0x60, 0x00,   // 0x3E, >
    0x3C, 0x66, 0x06, 0x0C, 0x18, 0x00, 0x18, 0x00,   // 0x3F, ?
    0x3E, 0x63, 0x6F, 0x6F, 0x6F, 0x60, 0x3E, 0x00,   // 0x40, @
    0x18, 0x3C, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x00,   // 0x41, A
    0x7C, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x7C, 0x00,   // 0x42, B
    0x3C, 0x66, 0x60, 0x60, 0x60, 0x66, 0x3C, 0x00,   // 0x43, C
    0x78, 0x6C, 0x66, 0x66, 0x66, 0x6C, 0x78, 0x00,   // 0x44, D
    0x7E, 0x60, 0x60, 0x78, 0x60, 0x60, 0x7E, 0x00,   // 0x45, E
    0x7E, 0x60, 0x60, 0x78, 0x60, 0x60, 0x60, 0x00,   // 0x46, F
    0x3C, 0x66, 0x60, 0x6E, 0x66, 0x66, 0x3C, 0x00,   // 0x47, G
    0x66, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x00,   // 0x48, H
    0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00,   // 0x49, I
    0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x6C, 0x38, 0x00,   // 0x4A, J
    0x66, 0x6C, 0x78, 0x70, 0x78, 0x6C, 0x66, 0x00,   // 0x4B, K
    0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x7E, 0x00,   // 0x4C, L
    0x63, 0x77, 0x7F, 0x6B, 0x63, 0x63, 0x63, 0x00,   // 0x4D, M
    0x66, 0x76, 0x7E, 0x7E, 0x6E, 0x66, 0x66, 0x00,   // 0x4E, N
    0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00,   // 0x4F, O
    0x7C, 0x66, 0x66, 0x7C, 0x60, 0x60, 0x60, 0x00,   // 0x50, P
    0x3C, 0x66, 0x66, 0x66, 0x6A, 0x6C, 0x36, 0x00,   // 0x51, Q
    0x7C, 0x66, 0x66, 0x7C, 0x78, 0x6C, 0x66, 0x00,   // 0x52, R
    0x3C, 0x66, 0x60, 0x3C, 0x06, 0x66, 0x3C, 0x00,   // 0x53, S
    0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00,   // 0x54, T
    0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00,   // 0x55, U
    0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00,   // 0x56, V
    0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00,   // 0x57, W
    0x66, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x66, 0x00,   // 0x58, X
    0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x18, 0x00,   // 0x59, Y
    0x7E, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x7E, 0x00,   // 0x5A, Z
    0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00,   // 0x5B, [
    0x40, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x03, 0x00,   // 0x5C, slash
    0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00,   // 0x5D, ]
    0x18, 0x3C, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x5E, ^
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,   // 0x5F, _
    0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x60, `
    0x00, 0x00, 0x3C, 0x06, 0x3E, 0x66, 0x3E, 0x00,   // 0x61, a
    0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x7C, 0x00,   // 0x62, b
    0x00, 0x00, 0x3C, 0x66, 0x60, 0x66, 0x3C, 0x00,   // 0x63, c
    0x06, 0x06, 0x3E, 0x66, 0x66, 0x66, 0x3E, 0x00,   // 0x64, d
    0x00, 0x00, 0x3C, 0x66, 0x7E, 0x60, 0x3C, 0x00,   // 0x65, e
    0x1C, 0x36, 0x30, 0x7C, 0x30, 0x30, 0x30, 0x00,   // 0x66, f
    0x00, 0x00, 0x3E, 0x66, 0x66, 0x3E, 0x06, 0x7C,   // 0x67, g
    0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x00,   // 0x68, h
    0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x3C, 0x00,   // 0x69, i
    0x0C, 0x00, 0x1C, 0x0C, 0x0C, 0x0C, 0x6C, 0x38,   // 0x6A, j
    0x60, 0x60, 0x66, 0x6C, 0x78, 0x6C, 0x66, 0x00,   // 0x6B, k
    0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00,   // 0x6C, l
    0x00, 0x00, 0x66, 0x7F, 0x7F, 0x6B, 0x63, 0x00,   // 0x6D, m
    0x00, 0x00, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x00,   // 0x6E, n
    0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x3C, 0x00,   // 0x6F, o
    0x00, 0x00, 0x7C, 0x66, 0x66, 0x7C, 0x60, 0x60,   // 0x70, p
    0x00, 0x00, 0x3E, 0x66, 0x66, 0x3E, 0x06, 0x06,   // 0x71, q
    0x00, 0x00, 0x7C, 0x66, 0x60, 0x60, 0x60, 0x00,   // 0x72, r
    0x00, 0x00, 0x3E, 0x60, 0x3C, 0x06, 0x7C, 0x00,   // 0x73, s
    0x30, 0x30, 0x7C, 0x30, 0x30, 0x36, 0x1C, 0x00,   // 0x74, t
    0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3E, 0x00,   // 0x75, u
    0x00, 0x00, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00,   // 0x76, v
    0x00, 0x00, 0x63, 0x6B, 0x7F, 0x7F, 0x36, 0x00,   // 0x77, w
    0x00, 0x00, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x00,   // 0x78, x
    0x00, 0x00, 0x66, 0x66, 0x66, 0x3E, 0x06, 0x7C,   // 0x79, y
    0x00, 0x00, 0x7E, 0x0C, 0x18, 0x30, 0x7E, 0x00,   // 0x7A, z
    0x0E, 0x18, 0x18, 0x70, 0x18, 0x18, 0x0E, 0x00,   // 0x7B, {
    0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00,   // 0x7C, |
    0x70, 0x18, 0x18, 0x0E, 0x18, 0x18, 0x70, 0x00,   // 0x7D, }
    0x3B, 0x6E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x7E, ~
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00    // 0x7F, DEL
};


// Global variables for text scrolling
static String currentText = "PixelBoard";
static int scrollPosition = 0;
static CRGB textColor = CRGB::White;
static unsigned long lastUpdate = 0;
static const int scrollDelay = 50;  // Delay between scroll steps in ms
static bool useLargeFont = false;
static bool useMonoFont = false;    // New variable for the FreeMono font
static bool useTestFont = false;    // New variable for the test font

// Helper function to get character index in font array
int getCharIndex(char c, bool isLargeFont) {
    if (useTestFont) {
        // Test font handles its own character mapping
        return 0;
    } else if (useMonoFont) {
        // FreeMono font handles its own character mapping
        return 0;
    } else if (isLargeFont) {
        // For 8x8 font, we can directly use ASCII value offset
        return c;
    } else {
        // For 5x7 font
        // Check for valid characters
        if (c < 32 || c > 126) {
            c = '?'; // Use question mark for invalid characters
        }
        return c - 32; // Adjust for font array that starts at ASCII 32 (space)
    }
}

void drawChar(CRGB* leds, char c, int xOffset, int yOffset) {
    int charIndex = getCharIndex(c, false);
    
    for (int x = 0; x < 5; x++) {
        if (xOffset + x < 0 || xOffset + x >= 16) continue;
        
        uint8_t column = pgm_read_byte(&font5x7[charIndex * 5 + x]);
        for (int y = 0; y < 7; y++) {
            if (yOffset + y < 0 || yOffset + y >= 16) continue;
            
            if (column & (1 << y)) {
                leds[XY(xOffset + x, yOffset + y)] = textColor;
            }
        }
    }
}

void drawCharLarge(CRGB* leds, char c, int xOffset, int yOffset) {
    int charIndex = getCharIndex(c, true);
    
    for (int y = 0; y < 8; y++) {
        if (yOffset + y < 0 || yOffset + y >= 16) continue;
        
        uint8_t row = pgm_read_byte(&font8x8[charIndex * 8 + y]);
        for (int x = 0; x < 8; x++) {
            if (xOffset + x < 0 || xOffset + x >= 16) continue;
            
            // Read bits from right to left to maintain correct orientation
            if (row & (1 << (7 - x))) {
                leds[XY(xOffset + x, yOffset + y)] = textColor;
            }
        }
    }
}

// New function to draw characters using the FreeMono font
void drawCharMono(CRGB* leds, unsigned char c, int xOffset, int yOffset, uint8_t size = 1) {
    // Make sure the character is in range for the font
    if (c < 0x20 || c > 0x7E) {
        c = '?'; // Use question mark for invalid characters
    }
    
    // Get the character descriptor from the GFXfont
    const GFXglyph *glyph = &FreeMono24pt7bGlyphs[c - 0x20];
    const uint8_t *bitmap = FreeMono24pt7bBitmaps;
    
    uint16_t bo = glyph->bitmapOffset;
    uint8_t w = glyph->width, h = glyph->height;
    int8_t xo = glyph->xOffset, yo = glyph->yOffset;
    uint8_t xx, yy, bits = 0, bit = 0;
    
    // Scale factor (reduce the size of the large font)
    float scale = 0.3; // Increased from 0.2 to make the font more visible
    
    // Loop through the bitmap data
    for (yy = 0; yy < h; yy++) {
        for (xx = 0; xx < w; xx++) {
            if (!(bit++ & 7)) {
                bits = pgm_read_byte(&bitmap[bo++]);
            }
            
            // Calculate the position on the LED matrix
            int16_t x = xOffset + (int16_t)(xo + xx) * scale;
            int16_t y = yOffset + (int16_t)(yo + yy) * scale + 6; // Added vertical offset to center better
            
            // Check if the bit is set in the bitmap and if the pixel is within the display
            if (bits & 0x80 && x >= 0 && x < 16 && y >= 0 && y < 16) {
                leds[XY(x, y)] = textColor;
            }
            
            bits <<= 1;
        }
    }
}

// New function to draw characters using the test font
void drawCharTest(CRGB* leds, char c, int xOffset, int yOffset, uint8_t size = 1) {
    // Initialize font table if needed
    static bool fontInitialized = false;
    if (!fontInitialized) {
        initFontTable();
        fontInitialized = true;
    }
    
    // Get the letter data for the character
    const LetterData& letter = getLetterData(c);
    
    // If no valid data, skip
    if (letter.data == nullptr) {
        return;
    }
    
    // Scale factor for the font
    float scale = 0.05; // Adjust this as needed to fit the display
    
    // Dimensions of original bitmap (assuming 12 pixels per row in the bitmap)
    int bitmapWidth = letter.width / 12;
    
    // Loop through the bitmap data
    for (int y = 0; y < letter.height; y++) {
        for (int x = 0; x < bitmapWidth; x++) {
            // Calculate index into the data array
            int dataIndex = y * bitmapWidth + x;
            
            // Get the value at this position (0-255)
            uint8_t pixelValue = letter.data[dataIndex];
            
            // If pixel has a value, draw it
            if (pixelValue > 0) {
                // Calculate the position on the LED matrix with scaling
                int16_t displayX = xOffset + (int16_t)(x * scale);
                int16_t displayY = yOffset + (int16_t)(y * scale);
                
                // Check if the pixel is within the display
                if (displayX >= 0 && displayX < 16 && displayY >= 0 && displayY < 16) {
                    // Set color based on pixel value (brighter for higher values)
                    CRGB pixelColor = textColor;
                    pixelColor.nscale8_video(map(pixelValue, 1, 255, 64, 255));
                    leds[XY(displayX, displayY)] = pixelColor;
                }
            }
        }
    }
}

void type(CRGB* leds) {
    // Clear the display
    fill_solid(leds, NUM_LEDS, CRGB::Black);
    
    // Calculate total width of text
    int charWidth;
    if (useTestFont) {
        charWidth = 8; // Adjust based on your test font
    } else if (useMonoFont) {
        charWidth = 8; // Increased from 6 to give more space between characters
    } else {
        charWidth = useLargeFont ? 9 : 6; // 8 pixels + 1 space or 5 pixels + 1 space
    }
    
    int totalWidth = currentText.length() * charWidth;
    
    // Update scroll position
    unsigned long currentTime = millis();
    if (currentTime - lastUpdate > scrollDelay) {
        scrollPosition++;
        if (scrollPosition >= totalWidth + 16) {
            scrollPosition = -16;
        }
        lastUpdate = currentTime;
    }
    
    // Draw each character
    for (size_t i = 0; i < currentText.length(); i++) {
        int xPos = 16 - scrollPosition + (i * charWidth);
        if (xPos > -charWidth && xPos < 16) {
            if (useTestFont) {
                drawCharTest(leds, currentText[i], xPos, 4); // Draw using test font
            } else if (useMonoFont) {
                drawCharMono(leds, currentText[i], xPos, 4); // Draw using FreeMono font
            } else if (useLargeFont) {
                drawCharLarge(leds, currentText[i], xPos, 4); // Center vertically for 8x8 font
            } else {
                drawChar(leds, currentText[i], xPos, 4); // Center vertically for 5x7 font
            }
        }
    }
}

void setupTypePattern(AsyncWebServer* server) {
    server->on("/type", HTTP_GET, [](AsyncWebServerRequest *request) {
        String html = R"rawliteral(
<!DOCTYPE html>
<html>
<head>
    <title>PixelBoard Type</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            text-align: center;
            background-color: #f0f0f0;
            color: #333;
        }
        .container {
            max-width: 600px;
            margin: 0 auto;
            background: #fff;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        input[type="text"] {
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
        }
        .color-selection, .font-selection {
            margin: 15px 0;
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
        }
        .color-btn, .font-btn {
            margin: 5px;
            padding: 8px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
        }
        .font-btn.active, .color-btn.active {
            transform: scale(1.1);
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .header {
            margin-bottom: 20px;
        }
        h1 {
            color: #2c3e50;
            margin-bottom: 5px;
        }
        .status {
            color: #7f8c8d;
            font-weight: bold;
        }
        button[type="submit"] {
            background: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 15px;
            font-size: 16px;
        }
        button[type="submit"]:hover {
            background: #2980b9;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>PixelBoard Text Display</h1>
            <div class="status">Enter text to display</div>
        </div>
        
        <input type="text" id="text-input" placeholder="Enter text to display" value="PixelBoard">
        
        <div class="color-selection">
            <button class="color-btn active" style="background-color: #FFFFFF;" data-color="white"></button>
            <button class="color-btn" style="background-color: #FF0000;" data-color="red"></button>
            <button class="color-btn" style="background-color: #00FF00;" data-color="green"></button>
            <button class="color-btn" style="background-color: #0000FF;" data-color="blue"></button>
            <button class="color-btn" style="background-color: #FFFF00;" data-color="yellow"></button>
            <button class="color-btn" style="background-color: #FF00FF;" data-color="purple"></button>
            <button class="color-btn" style="background-color: #00FFFF;" data-color="cyan"></button>
        </div>
        
        <div class="font-selection">
            <button class="font-btn active" data-size="small">Small</button>
            <button class="font-btn" data-size="large">Large</button>
            <button class="font-btn" data-size="mono">Mono</button>
            <button class="font-btn" data-size="test">Test Font</button>
        </div>
        
        <button type="submit" id="submit-btn">Update Display</button>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            let activeColor = 'white';
            let textInput = document.getElementById('text-input');
            
            // Set active color button
            document.querySelectorAll('.color-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    activeColor = this.dataset.color;
                });
            });
            
            // Function to update the text display
            function updateDisplay() {
                let text = textInput.value || 'PixelBoard';
                let fontSize = document.querySelector('.font-btn.active').dataset.size;
                
                fetch(`/updatetext?text=${encodeURIComponent(text)}&color=${activeColor}&font=${fontSize}`)
                    .then(response => response.text())
                    .then(data => {
                        console.log('Success:', data);
                    })
                    .catch(error => {
                        console.error('Error:', error);
                    });
            }
            
            // Submit button event listener
            document.getElementById('submit-btn').addEventListener('click', updateDisplay);
            
            // Set active font button
            document.querySelectorAll('.font-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.font-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                });
            });
            
            // Allow Enter key to submit
            textInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    updateDisplay();
                }
            });
            
            // Also update when font or color changes
            document.querySelectorAll('.font-btn, .color-btn').forEach(btn => {
                btn.addEventListener('click', updateDisplay);
            });
        });
    </script>
</body>
</html>
)rawliteral";
        request->send(200, "text/html", html);
    });

    // API endpoint to update the text
    server->on("/updatetext", HTTP_GET, [](AsyncWebServerRequest *request) {
        if (request->hasParam("text") && request->hasParam("color") && request->hasParam("font")) {
            String text = request->getParam("text")->value();
            String color = request->getParam("color")->value();
            String fontSize = request->getParam("font")->value();
            
            Serial.printf("Updating text: %s, Color: %s, Font: %s\n", text.c_str(), color.c_str(), fontSize.c_str());
            
            // Update text
            currentText = text;
            
            // Update color
            if (color == "red") textColor = CRGB::Red;
            else if (color == "green") textColor = CRGB::Green;
            else if (color == "blue") textColor = CRGB::Blue;
            else if (color == "yellow") textColor = CRGB::Yellow;
            else if (color == "purple") textColor = CRGB::Purple;
            else if (color == "cyan") textColor = CRGB::Cyan;
            else textColor = CRGB::White; // Default to white
            
            // Update font size
            useLargeFont = (fontSize == "large");
            useMonoFont = (fontSize == "mono");
            useTestFont = (fontSize == "test");
            
            // Reset position for scrolling
            // xPos = 16;
            
            request->send(200, "text/plain", "OK");
        } else {
            request->send(400, "text/plain", "Missing parameters");
        }
    });
} 