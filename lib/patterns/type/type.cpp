#include "type.h"
#include <led_display.h>
#include "freemono.h" // Include the FreeMono font
#include "font_test.h" // Include the test font



// Font data arrays
static const uint8_t font5x7[] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00,// (space)
	0x00, 0x00, 0x5F, 0x00, 0x00,// !
	0x00, 0x07, 0x00, 0x07, 0x00,// "
	0x14, 0x7F, 0x14, 0x7F, 0x14,// #
	0x24, 0x2A, 0x7F, 0x2A, 0x12,// $
	0x23, 0x13, 0x08, 0x64, 0x62,// %
	0x36, 0x49, 0x55, 0x22, 0x50,// &
	0x00, 0x05, 0x03, 0x00, 0x00,// '
	0x00, 0x1C, 0x22, 0x41, 0x00,// (
	0x00, 0x41, 0x22, 0x1C, 0x00,// )
	0x08, 0x2A, 0x1C, 0x2A, 0x08,// *
	0x08, 0x08, 0x3E, 0x08, 0x08,// +
	0x00, 0x50, 0x30, 0x00, 0x00,// ,
	0x08, 0x08, 0x08, 0x08, 0x08,// -
	0x00, 0x60, 0x60, 0x00, 0x00,// .
	0x20, 0x10, 0x08, 0x04, 0x02,// /
	0x3E, 0x51, 0x49, 0x45, 0x3E,// 0
	0x00, 0x42, 0x7F, 0x40, 0x00,// 1
	0x42, 0x61, 0x51, 0x49, 0x46,// 2
	0x21, 0x41, 0x45, 0x4B, 0x31,// 3
	0x18, 0x14, 0x12, 0x7F, 0x10,// 4
	0x27, 0x45, 0x45, 0x45, 0x39,// 5
	0x3C, 0x4A, 0x49, 0x49, 0x30,// 6
	0x01, 0x71, 0x09, 0x05, 0x03,// 7
	0x36, 0x49, 0x49, 0x49, 0x36,// 8
	0x06, 0x49, 0x49, 0x29, 0x1E,// 9
	0x00, 0x36, 0x36, 0x00, 0x00,// :
	0x00, 0x56, 0x36, 0x00, 0x00,// ;
	0x00, 0x08, 0x14, 0x22, 0x41,// <
	0x14, 0x14, 0x14, 0x14, 0x14,// =
	0x41, 0x22, 0x14, 0x08, 0x00,// >
	0x02, 0x01, 0x51, 0x09, 0x06,// ?
	0x32, 0x49, 0x79, 0x41, 0x3E,// @
	0x7E, 0x11, 0x11, 0x11, 0x7E,// A
	0x7F, 0x49, 0x49, 0x49, 0x36,// B
	0x3E, 0x41, 0x41, 0x41, 0x22,// C
	0x7F, 0x41, 0x41, 0x22, 0x1C,// D
	0x7F, 0x49, 0x49, 0x49, 0x41,// E
	0x7F, 0x09, 0x09, 0x01, 0x01,// F
	0x3E, 0x41, 0x41, 0x51, 0x32,// G
	0x7F, 0x08, 0x08, 0x08, 0x7F,// H
	0x00, 0x41, 0x7F, 0x41, 0x00,// I
	0x20, 0x40, 0x41, 0x3F, 0x01,// J
	0x7F, 0x08, 0x14, 0x22, 0x41,// K
	0x7F, 0x40, 0x40, 0x40, 0x40,// L
	0x7F, 0x02, 0x04, 0x02, 0x7F,// M
	0x7F, 0x04, 0x08, 0x10, 0x7F,// N
	0x3E, 0x41, 0x41, 0x41, 0x3E,// O
	0x7F, 0x09, 0x09, 0x09, 0x06,// P
	0x3E, 0x41, 0x51, 0x21, 0x5E,// Q
	0x7F, 0x09, 0x19, 0x29, 0x46,// R
	0x46, 0x49, 0x49, 0x49, 0x31,// S
	0x01, 0x01, 0x7F, 0x01, 0x01,// T
	0x3F, 0x40, 0x40, 0x40, 0x3F,// U
	0x1F, 0x20, 0x40, 0x20, 0x1F,// V
	0x7F, 0x20, 0x18, 0x20, 0x7F,// W
	0x63, 0x14, 0x08, 0x14, 0x63,// X
	0x03, 0x04, 0x78, 0x04, 0x03,// Y
	0x61, 0x51, 0x49, 0x45, 0x43,// Z
	0x00, 0x00, 0x7F, 0x41, 0x41,// [
	0x02, 0x04, 0x08, 0x10, 0x20,// "\"
	0x41, 0x41, 0x7F, 0x00, 0x00,// ]
	0x04, 0x02, 0x01, 0x02, 0x04,// ^
	0x40, 0x40, 0x40, 0x40, 0x40,// _
	0x00, 0x01, 0x02, 0x04, 0x00,// `
	0x20, 0x54, 0x54, 0x54, 0x78,// a
	0x7F, 0x48, 0x44, 0x44, 0x38,// b
	0x38, 0x44, 0x44, 0x44, 0x20,// c
	0x38, 0x44, 0x44, 0x48, 0x7F,// d
	0x38, 0x54, 0x54, 0x54, 0x18,// e
	0x08, 0x7E, 0x09, 0x01, 0x02,// f
	0x08, 0x14, 0x54, 0x54, 0x3C,// g
	0x7F, 0x08, 0x04, 0x04, 0x78,// h
	0x00, 0x44, 0x7D, 0x40, 0x00,// i
	0x20, 0x40, 0x44, 0x3D, 0x00,// j
	0x00, 0x7F, 0x10, 0x28, 0x44,// k
	0x00, 0x41, 0x7F, 0x40, 0x00,// l
	0x7C, 0x04, 0x18, 0x04, 0x78,// m
	0x7C, 0x08, 0x04, 0x04, 0x78,// n
	0x38, 0x44, 0x44, 0x44, 0x38,// o
	0x7C, 0x14, 0x14, 0x14, 0x08,// p
	0x08, 0x14, 0x14, 0x18, 0x7C,// q
	0x7C, 0x08, 0x04, 0x04, 0x08,// r
	0x48, 0x54, 0x54, 0x54, 0x20,// s
	0x04, 0x3F, 0x44, 0x40, 0x20,// t
	0x3C, 0x40, 0x40, 0x20, 0x7C,// u
	0x1C, 0x20, 0x40, 0x20, 0x1C,// v
	0x3C, 0x40, 0x30, 0x40, 0x3C,// w
	0x44, 0x28, 0x10, 0x28, 0x44,// x
	0x0C, 0x50, 0x50, 0x50, 0x3C,// y
	0x44, 0x64, 0x54, 0x4C, 0x44,// z
	0x00, 0x08, 0x36, 0x41, 0x00,// {
	0x00, 0x00, 0x7F, 0x00, 0x00,// |
	0x00, 0x41, 0x36, 0x08, 0x00,// }
	0x08, 0x08, 0x2A, 0x1C, 0x08,// ->
	0x08, 0x1C, 0x2A, 0x08, 0x08 // <-   
};



static const uint8_t font8x8[] PROGMEM = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x20, space
    0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00,   // 0x21, !
    0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x22, "
    0x6C, 0x6C, 0xFE, 0x6C, 0xFE, 0x6C, 0x6C, 0x00,   // 0x23, #
    0x18, 0x3E, 0x60, 0x3C, 0x06, 0x7C, 0x18, 0x00,   // 0x24, $
    0x00, 0x63, 0x66, 0x0C, 0x18, 0x33, 0x63, 0x00,   // 0x25, %
    0x1C, 0x36, 0x1C, 0x3B, 0x6E, 0x66, 0x3B, 0x00,   // 0x26, &
    0x0C, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x27, '
    0x0C, 0x18, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00,   // 0x28, (
    0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00,   // 0x29, )
    0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00,   // 0x2A, *
    0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00,   // 0x2B, +
    0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30,   // 0x2C, ,
    0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00,   // 0x2D, -
    0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00,   // 0x2E, .
    0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x40, 0x00,   // 0x2F, /
    0x3E, 0x63, 0x73, 0x7B, 0x6F, 0x67, 0x3E, 0x00,   // 0x30, 0
    0x18, 0x38, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00,   // 0x31, 1
    0x3C, 0x66, 0x06, 0x0C, 0x18, 0x30, 0x7E, 0x00,   // 0x32, 2
    0x3C, 0x66, 0x06, 0x1C, 0x06, 0x66, 0x3C, 0x00,   // 0x33, 3
    0x06, 0x0E, 0x1E, 0x36, 0x66, 0x7F, 0x06, 0x00,   // 0x34, 4
    0x7E, 0x60, 0x7C, 0x06, 0x06, 0x66, 0x3C, 0x00,   // 0x35, 5
    0x3C, 0x66, 0x60, 0x7C, 0x66, 0x66, 0x3C, 0x00,   // 0x36, 6
    0x7E, 0x66, 0x0C, 0x18, 0x18, 0x18, 0x18, 0x00,   // 0x37, 7
    0x3C, 0x66, 0x66, 0x3C, 0x66, 0x66, 0x3C, 0x00,   // 0x38, 8
    0x3C, 0x66, 0x66, 0x3E, 0x06, 0x66, 0x3C, 0x00,   // 0x39, 9
    0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x00,   // 0x3A, :
    0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x30,   // 0x3B, ;
    0x06, 0x0C, 0x18, 0x30, 0x18, 0x0C, 0x06, 0x00,   // 0x3C, <
    0x00, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x00, 0x00,   // 0x3D, =
    0x60, 0x30, 0x18, 0x0C, 0x18, 0x30, 0x60, 0x00,   // 0x3E, >
    0x3C, 0x66, 0x06, 0x0C, 0x18, 0x00, 0x18, 0x00,   // 0x3F, ?
    0x3E, 0x63, 0x6F, 0x6F, 0x6F, 0x60, 0x3E, 0x00,   // 0x40, @
    0x18, 0x3C, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x00,   // 0x41, A
    0x7C, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x7C, 0x00,   // 0x42, B
    0x3C, 0x66, 0x60, 0x60, 0x60, 0x66, 0x3C, 0x00,   // 0x43, C
    0x78, 0x6C, 0x66, 0x66, 0x66, 0x6C, 0x78, 0x00,   // 0x44, D
    0x7E, 0x60, 0x60, 0x78, 0x60, 0x60, 0x7E, 0x00,   // 0x45, E
    0x7E, 0x60, 0x60, 0x78, 0x60, 0x60, 0x60, 0x00,   // 0x46, F
    0x3C, 0x66, 0x60, 0x6E, 0x66, 0x66, 0x3C, 0x00,   // 0x47, G
    0x66, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x00,   // 0x48, H
    0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00,   // 0x49, I
    0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x6C, 0x38, 0x00,   // 0x4A, J
    0x66, 0x6C, 0x78, 0x70, 0x78, 0x6C, 0x66, 0x00,   // 0x4B, K
    0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x7E, 0x00,   // 0x4C, L
    0x63, 0x77, 0x7F, 0x6B, 0x63, 0x63, 0x63, 0x00,   // 0x4D, M
    0x66, 0x76, 0x7E, 0x7E, 0x6E, 0x66, 0x66, 0x00,   // 0x4E, N
    0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00,   // 0x4F, O
    0x7C, 0x66, 0x66, 0x7C, 0x60, 0x60, 0x60, 0x00,   // 0x50, P
    0x3C, 0x66, 0x66, 0x66, 0x6A, 0x6C, 0x36, 0x00,   // 0x51, Q
    0x7C, 0x66, 0x66, 0x7C, 0x78, 0x6C, 0x66, 0x00,   // 0x52, R
    0x3C, 0x66, 0x60, 0x3C, 0x06, 0x66, 0x3C, 0x00,   // 0x53, S
    0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00,   // 0x54, T
    0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00,   // 0x55, U
    0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00,   // 0x56, V
    0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00,   // 0x57, W
    0x66, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x66, 0x00,   // 0x58, X
    0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x18, 0x00,   // 0x59, Y
    0x7E, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x7E, 0x00,   // 0x5A, Z
    0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00,   // 0x5B, [
    0x40, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x03, 0x00,   // 0x5C, slash
    0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00,   // 0x5D, ]
    0x18, 0x3C, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x5E, ^
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,   // 0x5F, _
    0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x60, `
    0x00, 0x00, 0x3C, 0x06, 0x3E, 0x66, 0x3E, 0x00,   // 0x61, a
    0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x7C, 0x00,   // 0x62, b
    0x00, 0x00, 0x3C, 0x66, 0x60, 0x66, 0x3C, 0x00,   // 0x63, c
    0x06, 0x06, 0x3E, 0x66, 0x66, 0x66, 0x3E, 0x00,   // 0x64, d
    0x00, 0x00, 0x3C, 0x66, 0x7E, 0x60, 0x3C, 0x00,   // 0x65, e
    0x1C, 0x36, 0x30, 0x7C, 0x30, 0x30, 0x30, 0x00,   // 0x66, f
    0x00, 0x00, 0x3E, 0x66, 0x66, 0x3E, 0x06, 0x7C,   // 0x67, g
    0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x00,   // 0x68, h
    0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x3C, 0x00,   // 0x69, i
    0x0C, 0x00, 0x1C, 0x0C, 0x0C, 0x0C, 0x6C, 0x38,   // 0x6A, j
    0x60, 0x60, 0x66, 0x6C, 0x78, 0x6C, 0x66, 0x00,   // 0x6B, k
    0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00,   // 0x6C, l
    0x00, 0x00, 0x66, 0x7F, 0x7F, 0x6B, 0x63, 0x00,   // 0x6D, m
    0x00, 0x00, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x00,   // 0x6E, n
    0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x3C, 0x00,   // 0x6F, o
    0x00, 0x00, 0x7C, 0x66, 0x66, 0x7C, 0x60, 0x60,   // 0x70, p
    0x00, 0x00, 0x3E, 0x66, 0x66, 0x3E, 0x06, 0x06,   // 0x71, q
    0x00, 0x00, 0x7C, 0x66, 0x60, 0x60, 0x60, 0x00,   // 0x72, r
    0x00, 0x00, 0x3E, 0x60, 0x3C, 0x06, 0x7C, 0x00,   // 0x73, s
    0x30, 0x30, 0x7C, 0x30, 0x30, 0x36, 0x1C, 0x00,   // 0x74, t
    0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3E, 0x00,   // 0x75, u
    0x00, 0x00, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00,   // 0x76, v
    0x00, 0x00, 0x63, 0x6B, 0x7F, 0x7F, 0x36, 0x00,   // 0x77, w
    0x00, 0x00, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x00,   // 0x78, x
    0x00, 0x00, 0x66, 0x66, 0x66, 0x3E, 0x06, 0x7C,   // 0x79, y
    0x00, 0x00, 0x7E, 0x0C, 0x18, 0x30, 0x7E, 0x00,   // 0x7A, z
    0x0E, 0x18, 0x18, 0x70, 0x18, 0x18, 0x0E, 0x00,   // 0x7B, {
    0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00,   // 0x7C, |
    0x70, 0x18, 0x18, 0x0E, 0x18, 0x18, 0x70, 0x00,   // 0x7D, }
    0x3B, 0x6E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x7E, ~
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00    // 0x7F, DEL
};


// Global variables for text scrolling
static String currentText = "PixelBoard";
static int scrollPosition = 0;
static CRGB textColor = CRGB::White;
static CRGB backgroundColor = CRGB::Black;  // Add background color variable
static unsigned long lastUpdate = 0;
static const int scrollDelay = 50;  // Delay between scroll steps in ms
static bool useMonoFont = false;    // New variable for the FreeMono font

// Helper function to get character index in font array
int getCharIndex(char c) {
    if (useMonoFont) {
        // FreeMono font handles its own character mapping
        return 0;
    } else {
        // For 5x7 font
        // Check for valid characters
        if (c < 32 || c > 126) {
            c = '?'; // Use question mark for invalid characters
        }
        return c - 32; // Adjust for font array that starts at ASCII 32 (space)
    }
}

void drawChar(CRGB* leds, char c, int xOffset, int yOffset) {
    int charIndex = getCharIndex(c);
    
    for (int x = 0; x < 5; x++) {
        if (xOffset + x < 0 || xOffset + x >= 16) continue;
        
        uint8_t column = pgm_read_byte(&font5x7[charIndex * 5 + x]);
        for (int y = 0; y < 7; y++) {
            if (yOffset + y < 0 || yOffset + y >= 16) continue;
            
            if (column & (1 << y)) {
                leds[XY(xOffset + x, yOffset + y)] = textColor;
            }
        }
    }
}

void drawCharLarge(CRGB* leds, char c, int xOffset, int yOffset) {
    int charIndex = getCharIndex(c);
    
    for (int y = 0; y < 8; y++) {
        if (yOffset + y < 0 || yOffset + y >= 16) continue;
        
        uint8_t row = pgm_read_byte(&font8x8[charIndex * 8 + y]);
        for (int x = 0; x < 8; x++) {
            if (xOffset + x < 0 || xOffset + x >= 16) continue;
            
            // Read bits from left to right to match font data orientation
            if (row & (1 << x)) {
                leds[XY(xOffset + x, yOffset + y)] = textColor;
            }
        }
    }
}

// New function to draw characters using the FreeMono font
void drawCharMono(CRGB* leds, unsigned char c, int xOffset, int yOffset, uint8_t size = 1) {
    // Make sure the character is in range for the font
    if (c < 0x20 || c > 0x7E) {
        c = '?'; // Use question mark for invalid characters
    }
    
    // Get the character descriptor from the GFXfont
    const GFXglyph *glyph = &FreeMono24pt7bGlyphs[c - 0x20];
    const uint8_t *bitmap = FreeMono24pt7bBitmaps;
    
    uint16_t bo = glyph->bitmapOffset;
    uint8_t w = glyph->width, h = glyph->height;
    int8_t xo = glyph->xOffset, yo = glyph->yOffset;
    uint8_t xx, yy, bits = 0, bit = 0;
    
    // Scale factor (reduce the size of the large font)
    float scale = 0.3; // Increased from 0.2 to make the font more visible
    
    // Loop through the bitmap data
    for (yy = 0; yy < h; yy++) {
        for (xx = 0; xx < w; xx++) {
            if (!(bit++ & 7)) {
                bits = pgm_read_byte(&bitmap[bo++]);
            }
            
            // Calculate the position on the LED matrix
            int16_t x = xOffset + (int16_t)(xo + xx) * scale;
            int16_t y = yOffset + (int16_t)(yo + yy) * scale + 6; // Added vertical offset to center better
            
            // Check if the bit is set in the bitmap and if the pixel is within the display
            if (bits & 0x80 && x >= 0 && x < 16 && y >= 0 && y < 16) {
                leds[XY(x, y)] = textColor;
            }
            
            bits <<= 1;
        }
    }
}

// New function to draw characters using the test font
void drawCharTest(CRGB* leds, char c, int xOffset, int yOffset, uint8_t size = 1) {
    // Initialize font table if needed
    static bool fontInitialized = false;
    if (!fontInitialized) {
        initFontTable();
        fontInitialized = true;
    }
    
    // Get the letter data for the character
    const LetterData& letter = getLetterData(c);
    
    // If no valid data, skip
    if (letter.data == nullptr) {
        return;
    }
    
    // Scale factor for the font
    float scale = 0.05; // Adjust this as needed to fit the display
    
    // Dimensions of original bitmap (assuming 12 pixels per row in the bitmap)
    int bitmapWidth = letter.width / 12;
    
    // Loop through the bitmap data
    for (int y = 0; y < letter.height; y++) {
        for (int x = 0; x < bitmapWidth; x++) {
            // Calculate index into the data array
            int dataIndex = y * bitmapWidth + x;
            
            // Get the value at this position (0-255)
            uint8_t pixelValue = letter.data[dataIndex];
            
            // If pixel has a value, draw it
            if (pixelValue > 0) {
                // Calculate the position on the LED matrix with scaling
                int16_t displayX = xOffset + (int16_t)(x * scale);
                int16_t displayY = yOffset + (int16_t)(y * scale);
                
                // Check if the pixel is within the display
                if (displayX >= 0 && displayX < 16 && displayY >= 0 && displayY < 16) {
                    // Set color based on pixel value (brighter for higher values)
                    CRGB pixelColor = textColor;
                    pixelColor.nscale8_video(map(pixelValue, 1, 255, 64, 255));
                    leds[XY(displayX, displayY)] = pixelColor;
                }
            }
        }
    }
}

void type(CRGB* leds) {
    // Clear the display with background color instead of black
    fill_solid(leds, NUM_LEDS, backgroundColor);
    
    // Calculate total width of text
    int charWidth = useMonoFont ? 8 : 6; // 8 pixels for mono, 5 pixels + 1 space for small
    
    int totalWidth = currentText.length() * charWidth;
    
    // Update scroll position
    unsigned long currentTime = millis();
    if (currentTime - lastUpdate > scrollDelay) {
        scrollPosition++;
        if (scrollPosition >= totalWidth + 16) {
            scrollPosition = -16;
        }
        lastUpdate = currentTime;
    }
    
    // Draw each character
    for (size_t i = 0; i < currentText.length(); i++) {
        int xPos = 16 - scrollPosition + (i * charWidth);
        if (xPos > -charWidth && xPos < 16) {
            if (useMonoFont) {
                drawCharMono(leds, currentText[i], xPos, 4); // Draw using FreeMono font
            } else {
                drawChar(leds, currentText[i], xPos, 4); // Draw using 5x7 font
            }
        }
    }
}

void setupTypePattern(AsyncWebServer* server) {
    server->on("/type", HTTP_GET, [](AsyncWebServerRequest *request) {
        String html = R"rawliteral(
<!DOCTYPE html>
<html>
<head>
    <title>PixelBoard Text Display</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/style.css">
</head>
<body>
    <div class="preview-container">
        <div class="preview-grid" id="previewGrid"></div>
    </div>
    
    <div class="controls" style="display:block;">
        <div class="input-group">
            <input type="text" id="text-input" placeholder="Enter text to display" value="PixelBoard">
        </div>
        
        <div class="color-section">
            <div class="color-section-label">Text Color</div>
            <div class="color-selection" id="textColors">
                <button class="color-btn active" style="background-color: #FFFFFF;" data-color="white">White</button>
                <button class="color-btn" style="background-color: #FF0000;" data-color="red">Red</button>
                <button class="color-btn" style="background-color: #00FF00;" data-color="green">Green</button>
                <button class="color-btn" style="background-color: #0000FF;" data-color="blue">Blue</button>
                <button class="color-btn" style="background-color: #FFFF00;" data-color="yellow">Yellow</button>
                <button class="color-btn" style="background-color: #FF00FF;" data-color="purple">Purple</button>
                <button class="color-btn" style="background-color: #00FFFF;" data-color="cyan">Cyan</button>
            </div>
        </div>

        <div class="color-section">
            <div class="color-section-label">Background Color</div>
            <div class="color-selection" id="bgColors">
                <button class="color-btn active" style="background-color: #000000;" data-color="black">Black</button>
                <button class="color-btn" style="background-color: #FF0000;" data-color="red">Red</button>
                <button class="color-btn" style="background-color: #00FF00;" data-color="green">Green</button>
                <button class="color-btn" style="background-color: #0000FF;" data-color="blue">Blue</button>
                <button class="color-btn" style="background-color: #FFFF00;" data-color="yellow">Yellow</button>
                <button class="color-btn" style="background-color: #FF00FF;" data-color="purple">Purple</button>
                <button class="color-btn" style="background-color: #00FFFF;" data-color="cyan">Cyan</button>
            </div>
        </div>
        
        <div class="font-selection">
            <button class="font-btn active" data-size="small">Small Font</button>
            <button class="font-btn" data-size="mono">Mono Font</button>
        </div>
    </div>

    <script>
        let previewUpdateInterval;
        
        // Create preview grid
        function createPreviewGrid() {
            const grid = document.getElementById('previewGrid');
            for (let i = 0; i < 256; i++) {
                const pixel = document.createElement('div');
                pixel.className = 'preview-pixel';
                pixel.id = 'pixel-' + i;
                grid.appendChild(pixel);
            }
        }
        
        // Update the preview grid
        function updatePreview() {
            fetch('/pixelStatus')
                .then(response => response.arrayBuffer())
                .then(buffer => {
                    const pixels = new Uint8Array(buffer);
                    for (let i = 0; i < 256; i++) {
                        const baseIndex = i * 3;
                        const r = pixels[baseIndex];
                        const g = pixels[baseIndex + 1];
                        const b = pixels[baseIndex + 2];
                        
                        const pixelElement = document.getElementById('pixel-' + i);
                        if (pixelElement) {
                            pixelElement.style.backgroundColor = `rgb(${r},${g},${b})`;
                        }
                    }
                })
                .catch(error => console.error('Error updating preview:', error));
        }
        
        document.addEventListener('DOMContentLoaded', function() {
            let activeTextColor = 'white';
            let activeBgColor = 'black';
            let textInput = document.getElementById('text-input');
            
            // Set active color button for text colors
            document.querySelectorAll('#textColors .color-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('#textColors .color-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    activeTextColor = this.dataset.color;
                    updateDisplay();
                });
            });

            // Set active color button for background colors
            document.querySelectorAll('#bgColors .color-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('#bgColors .color-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    activeBgColor = this.dataset.color;
                    updateDisplay();
                });
            });
            
            // Function to update the text display
            function updateDisplay() {
                let text = textInput.value || 'PixelBoard';
                let fontSize = document.querySelector('.font-btn.active').dataset.size;
                
                fetch(`/updatetext?text=${encodeURIComponent(text)}&textColor=${activeTextColor}&bgColor=${activeBgColor}&font=${fontSize}`)
                    .then(response => response.text())
                    .catch(error => console.error('Error:', error));
            }
            
            // Set active font button
            document.querySelectorAll('.font-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.font-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    updateDisplay();
                });
            });
            
            // Allow Enter key to submit
            textInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    updateDisplay();
                }
            });
            
            // Update when text input changes
            textInput.addEventListener('input', updateDisplay);
            
            // Initialize
            createPreviewGrid();
            updatePreview();
            previewUpdateInterval = setInterval(updatePreview, 100);
        });
        
        // Clean up
        window.addEventListener('unload', function() {
            if (previewUpdateInterval) {
                clearInterval(previewUpdateInterval);
            }
        });
    </script>
</body>
</html>
)rawliteral";
        request->send(200, "text/html", html);
    });

    // API endpoint to update the text
    server->on("/updatetext", HTTP_GET, [](AsyncWebServerRequest *request) {
        if (request->hasParam("text") && request->hasParam("textColor") && request->hasParam("bgColor") && request->hasParam("font")) {
            String text = request->getParam("text")->value();
            String textColorStr = request->getParam("textColor")->value();
            String bgColorStr = request->getParam("bgColor")->value();
            String fontSize = request->getParam("font")->value();
            
            Serial.printf("Updating text: %s, Text Color: %s, Background Color: %s, Font: %s\n", 
                         text.c_str(), textColorStr.c_str(), bgColorStr.c_str(), fontSize.c_str());
            
            // Update text
            currentText = text;
            
            // Update text color
            if (textColorStr == "red") textColor = CRGB::Red;
            else if (textColorStr == "green") textColor = CRGB::Green;
            else if (textColorStr == "blue") textColor = CRGB::Blue;
            else if (textColorStr == "yellow") textColor = CRGB::Yellow;
            else if (textColorStr == "purple") textColor = CRGB::Purple;
            else if (textColorStr == "cyan") textColor = CRGB::Cyan;
            else textColor = CRGB::White; // Default to white

            // Update background color
            if (bgColorStr == "red") backgroundColor = CRGB::Red;
            else if (bgColorStr == "green") backgroundColor = CRGB::Green;
            else if (bgColorStr == "blue") backgroundColor = CRGB::Blue;
            else if (bgColorStr == "yellow") backgroundColor = CRGB::Yellow;
            else if (bgColorStr == "purple") backgroundColor = CRGB::Purple;
            else if (bgColorStr == "cyan") backgroundColor = CRGB::Cyan;
            else if (bgColorStr == "white") backgroundColor = CRGB::White;
            else backgroundColor = CRGB::Black; // Default to black
            
            // Update font size
            useMonoFont = (fontSize == "mono");
            
            request->send(200, "text/plain", "OK");
        } else {
            request->send(400, "text/plain", "Missing parameters");
        }
    });
} 