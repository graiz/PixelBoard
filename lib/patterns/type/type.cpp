#include "type.h"
#include <led_display.h>



// Font data arrays
static const uint8_t font5x7[] PROGMEM = {
    0x00, 0x00, 0x00, 0x00, 0x00, // Space
    0x00, 0x00, 0x5F, 0x00, 0x00, // !
    0x00, 0x07, 0x00, 0x07, 0x00, // "
    0x14, 0x7F, 0x14, 0x7F, 0x14, // #
    0x24, 0x2A, 0x7F, 0x2A, 0x12, // $
    0x23, 0x13, 0x08, 0x64, 0x62, // %
    0x36, 0x49, 0x55, 0x22, 0x50, // &
    0x00, 0x05, 0x03, 0x00, 0x00, // '
    0x00, 0x1C, 0x22, 0x41, 0x00, // (
    0x00, 0x41, 0x22, 0x1C, 0x00, // )
    0x08, 0x2A, 0x1C, 0x2A, 0x08, // *
    0x08, 0x08, 0x3E, 0x08, 0x08, // +
    0x00, 0x50, 0x30, 0x00, 0x00, // ,
    0x08, 0x08, 0x08, 0x08, 0x08, // -
    0x00, 0x60, 0x60, 0x00, 0x00, // .
    0x20, 0x10, 0x08, 0x04, 0x02, // /
    0x3E, 0x51, 0x49, 0x45, 0x3E, // 0
    0x00, 0x42, 0x7F, 0x40, 0x00, // 1
    0x42, 0x61, 0x51, 0x49, 0x46, // 2
    0x21, 0x41, 0x45, 0x4B, 0x31, // 3
    0x18, 0x14, 0x12, 0x7F, 0x10, // 4
    0x27, 0x45, 0x45, 0x45, 0x39, // 5
    0x3C, 0x4A, 0x49, 0x49, 0x30, // 6
    0x01, 0x71, 0x09, 0x05, 0x03, // 7
    0x36, 0x49, 0x49, 0x49, 0x36, // 8
    0x06, 0x49, 0x49, 0x29, 0x1E, // 9
    0x00, 0x36, 0x36, 0x00, 0x00, // :
    0x00, 0x56, 0x36, 0x00, 0x00, // ;
    0x00, 0x08, 0x14, 0x22, 0x41, // <
    0x14, 0x14, 0x14, 0x14, 0x14, // =
    0x41, 0x22, 0x14, 0x08, 0x00, // >
    0x02, 0x01, 0x51, 0x09, 0x06, // ?
    0x32, 0x49, 0x79, 0x41, 0x3E, // @
    0x7E, 0x11, 0x11, 0x11, 0x7E, // A
    0x7F, 0x49, 0x49, 0x49, 0x36, // B
    0x3E, 0x41, 0x41, 0x41, 0x22, // C
    0x7F, 0x41, 0x41, 0x22, 0x1C, // D
    0x7F, 0x49, 0x49, 0x49, 0x41, // E
    0x7F, 0x09, 0x09, 0x01, 0x01, // F
    0x3E, 0x41, 0x41, 0x51, 0x32, // G
    0x7F, 0x08, 0x08, 0x08, 0x7F, // H
    0x00, 0x41, 0x7F, 0x41, 0x00, // I
    0x20, 0x40, 0x41, 0x3F, 0x01, // J
    0x7F, 0x08, 0x14, 0x22, 0x41, // K
    0x7F, 0x40, 0x40, 0x40, 0x40, // L
    0x7F, 0x02, 0x04, 0x02, 0x7F, // M
    0x7F, 0x04, 0x08, 0x10, 0x7F, // N
    0x3E, 0x41, 0x41, 0x41, 0x3E, // O
    0x7F, 0x09, 0x09, 0x09, 0x06, // P
    0x3E, 0x41, 0x51, 0x21, 0x5E, // Q
    0x7F, 0x09, 0x19, 0x29, 0x46, // R
    0x46, 0x49, 0x49, 0x49, 0x31, // S
    0x01, 0x01, 0x7F, 0x01, 0x01, // T
    0x3F, 0x40, 0x40, 0x40, 0x3F, // U
    0x1F, 0x20, 0x40, 0x20, 0x1F, // V
    0x7F, 0x20, 0x18, 0x20, 0x7F, // W
    0x63, 0x14, 0x08, 0x14, 0x63, // X
    0x03, 0x04, 0x78, 0x04, 0x03, // Y
    0x61, 0x51, 0x49, 0x45, 0x43, // Z
    0x00, 0x00, 0x7F, 0x41, 0x41, // [
    0x02, 0x04, 0x08, 0x10, 0x20, // slash
    0x41, 0x41, 0x7F, 0x00, 0x00, // ]
    0x04, 0x02, 0x01, 0x02, 0x04, // ^
    0x40, 0x40, 0x40, 0x40, 0x40, // _
    0x00, 0x01, 0x02, 0x04, 0x00  // `
};

static const uint8_t font8x8[] PROGMEM = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x20, space
    0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00,   // 0x21, !
    0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x22, "
    0x6C, 0x6C, 0xFE, 0x6C, 0xFE, 0x6C, 0x6C, 0x00,   // 0x23, #
    0x18, 0x3E, 0x60, 0x3C, 0x06, 0x7C, 0x18, 0x00,   // 0x24, $
    0x00, 0x63, 0x66, 0x0C, 0x18, 0x33, 0x63, 0x00,   // 0x25, %
    0x1C, 0x36, 0x1C, 0x3B, 0x6E, 0x66, 0x3B, 0x00,   // 0x26, &
    0x0C, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x27, '
    0x0C, 0x18, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00,   // 0x28, (
    0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00,   // 0x29, )
    0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00,   // 0x2A, *
    0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00,   // 0x2B, +
    0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30,   // 0x2C, ,
    0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00,   // 0x2D, -
    0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00,   // 0x2E, .
    0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x40, 0x00,   // 0x2F, /
    0x3E, 0x63, 0x73, 0x7B, 0x6F, 0x67, 0x3E, 0x00,   // 0x30, 0
    0x18, 0x38, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00,   // 0x31, 1
    0x3C, 0x66, 0x06, 0x0C, 0x18, 0x30, 0x7E, 0x00,   // 0x32, 2
    0x3C, 0x66, 0x06, 0x1C, 0x06, 0x66, 0x3C, 0x00,   // 0x33, 3
    0x06, 0x0E, 0x1E, 0x36, 0x66, 0x7F, 0x06, 0x00,   // 0x34, 4
    0x7E, 0x60, 0x7C, 0x06, 0x06, 0x66, 0x3C, 0x00,   // 0x35, 5
    0x3C, 0x66, 0x60, 0x7C, 0x66, 0x66, 0x3C, 0x00,   // 0x36, 6
    0x7E, 0x66, 0x0C, 0x18, 0x18, 0x18, 0x18, 0x00,   // 0x37, 7
    0x3C, 0x66, 0x66, 0x3C, 0x66, 0x66, 0x3C, 0x00,   // 0x38, 8
    0x3C, 0x66, 0x66, 0x3E, 0x06, 0x66, 0x3C, 0x00,   // 0x39, 9
    0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x00,   // 0x3A, :
    0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x30,   // 0x3B, ;
    0x06, 0x0C, 0x18, 0x30, 0x18, 0x0C, 0x06, 0x00,   // 0x3C, <
    0x00, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x00, 0x00,   // 0x3D, =
    0x60, 0x30, 0x18, 0x0C, 0x18, 0x30, 0x60, 0x00,   // 0x3E, >
    0x3C, 0x66, 0x06, 0x0C, 0x18, 0x00, 0x18, 0x00,   // 0x3F, ?
    0x3E, 0x63, 0x6F, 0x6F, 0x6F, 0x60, 0x3E, 0x00,   // 0x40, @
    0x18, 0x3C, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x00,   // 0x41, A
    0x7C, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x7C, 0x00,   // 0x42, B
    0x3C, 0x66, 0x60, 0x60, 0x60, 0x66, 0x3C, 0x00,   // 0x43, C
    0x78, 0x6C, 0x66, 0x66, 0x66, 0x6C, 0x78, 0x00,   // 0x44, D
    0x7E, 0x60, 0x60, 0x78, 0x60, 0x60, 0x7E, 0x00,   // 0x45, E
    0x7E, 0x60, 0x60, 0x78, 0x60, 0x60, 0x60, 0x00,   // 0x46, F
    0x3C, 0x66, 0x60, 0x6E, 0x66, 0x66, 0x3C, 0x00,   // 0x47, G
    0x66, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x00,   // 0x48, H
    0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00,   // 0x49, I
    0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x6C, 0x38, 0x00,   // 0x4A, J
    0x66, 0x6C, 0x78, 0x70, 0x78, 0x6C, 0x66, 0x00,   // 0x4B, K
    0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x7E, 0x00,   // 0x4C, L
    0x63, 0x77, 0x7F, 0x6B, 0x63, 0x63, 0x63, 0x00,   // 0x4D, M
    0x66, 0x76, 0x7E, 0x7E, 0x6E, 0x66, 0x66, 0x00,   // 0x4E, N
    0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00,   // 0x4F, O
    0x7C, 0x66, 0x66, 0x7C, 0x60, 0x60, 0x60, 0x00,   // 0x50, P
    0x3C, 0x66, 0x66, 0x66, 0x6A, 0x6C, 0x36, 0x00,   // 0x51, Q
    0x7C, 0x66, 0x66, 0x7C, 0x78, 0x6C, 0x66, 0x00,   // 0x52, R
    0x3C, 0x66, 0x60, 0x3C, 0x06, 0x66, 0x3C, 0x00,   // 0x53, S
    0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00,   // 0x54, T
    0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00,   // 0x55, U
    0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00,   // 0x56, V
    0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00,   // 0x57, W
    0x66, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x66, 0x00,   // 0x58, X
    0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x18, 0x00,   // 0x59, Y
    0x7E, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x7E, 0x00,   // 0x5A, Z
    0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00,   // 0x5B, [
    0x40, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x03, 0x00,   // 0x5C, slash
    0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00,   // 0x5D, ]
    0x18, 0x3C, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x5E, ^
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,   // 0x5F, _
    0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x60, `
    0x00, 0x00, 0x3C, 0x06, 0x3E, 0x66, 0x3E, 0x00,   // 0x61, a
    0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x7C, 0x00,   // 0x62, b
    0x00, 0x00, 0x3C, 0x66, 0x60, 0x66, 0x3C, 0x00,   // 0x63, c
    0x06, 0x06, 0x3E, 0x66, 0x66, 0x66, 0x3E, 0x00,   // 0x64, d
    0x00, 0x00, 0x3C, 0x66, 0x7E, 0x60, 0x3C, 0x00,   // 0x65, e
    0x1C, 0x36, 0x30, 0x7C, 0x30, 0x30, 0x30, 0x00,   // 0x66, f
    0x00, 0x00, 0x3E, 0x66, 0x66, 0x3E, 0x06, 0x7C,   // 0x67, g
    0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x00,   // 0x68, h
    0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x3C, 0x00,   // 0x69, i
    0x0C, 0x00, 0x1C, 0x0C, 0x0C, 0x0C, 0x6C, 0x38,   // 0x6A, j
    0x60, 0x60, 0x66, 0x6C, 0x78, 0x6C, 0x66, 0x00,   // 0x6B, k
    0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00,   // 0x6C, l
    0x00, 0x00, 0x66, 0x7F, 0x7F, 0x6B, 0x63, 0x00,   // 0x6D, m
    0x00, 0x00, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x00,   // 0x6E, n
    0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x3C, 0x00,   // 0x6F, o
    0x00, 0x00, 0x7C, 0x66, 0x66, 0x7C, 0x60, 0x60,   // 0x70, p
    0x00, 0x00, 0x3E, 0x66, 0x66, 0x3E, 0x06, 0x06,   // 0x71, q
    0x00, 0x00, 0x7C, 0x66, 0x60, 0x60, 0x60, 0x00,   // 0x72, r
    0x00, 0x00, 0x3E, 0x60, 0x3C, 0x06, 0x7C, 0x00,   // 0x73, s
    0x30, 0x30, 0x7C, 0x30, 0x30, 0x36, 0x1C, 0x00,   // 0x74, t
    0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3E, 0x00,   // 0x75, u
    0x00, 0x00, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00,   // 0x76, v
    0x00, 0x00, 0x63, 0x6B, 0x7F, 0x7F, 0x36, 0x00,   // 0x77, w
    0x00, 0x00, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x00,   // 0x78, x
    0x00, 0x00, 0x66, 0x66, 0x66, 0x3E, 0x06, 0x7C,   // 0x79, y
    0x00, 0x00, 0x7E, 0x0C, 0x18, 0x30, 0x7E, 0x00,   // 0x7A, z
    0x0E, 0x18, 0x18, 0x70, 0x18, 0x18, 0x0E, 0x00,   // 0x7B, {
    0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00,   // 0x7C, |
    0x70, 0x18, 0x18, 0x0E, 0x18, 0x18, 0x70, 0x00,   // 0x7D, }
    0x3B, 0x6E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x7E, ~
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00    // 0x7F, DEL
};


// Global variables for text scrolling
static String currentText = "HELLO";
static int scrollPosition = 0;
static CRGB textColor = CRGB::White;
static unsigned long lastUpdate = 0;
static const int scrollDelay = 50;  // Delay between scroll steps in ms
static bool useLargeFont = false;

// Helper function to get character index in font array
int getCharIndex(char c, bool isLargeFont) {
    if (isLargeFont) {
        // For 8x8 font, we can directly use ASCII value offset
        if (c >= 0x20 && c <= 0x7F) {
            return c - 0x20;
        }
        return 0; // Return space for invalid characters
    } else {
        // For 5x7 font
        if (c >= 0x20 && c <= 0x60) {
            return c - 0x20;
        }
        return 0; // Return space for invalid characters
    }
}

void drawChar(CRGB* leds, char c, int xOffset, int yOffset) {
    int charIndex = getCharIndex(c, false);
    
    for (int x = 0; x < 5; x++) {
        if (xOffset + x < 0 || xOffset + x >= 16) continue;
        
        uint8_t column = pgm_read_byte(&font5x7[charIndex * 5 + x]);
        for (int y = 0; y < 7; y++) {
            if (yOffset + y < 0 || yOffset + y >= 16) continue;
            
            if (column & (1 << y)) {
                leds[XY(xOffset + x, yOffset + y)] = textColor;
            }
        }
    }
}

void drawCharLarge(CRGB* leds, char c, int xOffset, int yOffset) {
    int charIndex = getCharIndex(c, true);
    
    for (int y = 0; y < 8; y++) {
        if (yOffset + y < 0 || yOffset + y >= 16) continue;
        
        uint8_t row = pgm_read_byte(&font8x8[charIndex * 8 + y]);
        for (int x = 0; x < 8; x++) {
            if (xOffset + x < 0 || xOffset + x >= 16) continue;
            
            // Read bits from right to left to maintain correct orientation
            if (row & (1 << (7 - x))) {
                leds[XY(xOffset + x, yOffset + y)] = textColor;
            }
        }
    }
}

void type(CRGB* leds) {
    // Clear the display
    fill_solid(leds, NUM_LEDS, CRGB::Black);
    
    // Calculate total width of text
    int charWidth = useLargeFont ? 9 : 6; // 8 pixels + 1 space or 5 pixels + 1 space
    int totalWidth = currentText.length() * charWidth;
    
    // Update scroll position
    unsigned long currentTime = millis();
    if (currentTime - lastUpdate > scrollDelay) {
        scrollPosition++;
        if (scrollPosition >= totalWidth + 16) {
            scrollPosition = -16;
        }
        lastUpdate = currentTime;
    }
    
    // Draw each character
    for (size_t i = 0; i < currentText.length(); i++) {
        int xPos = 16 - scrollPosition + (i * charWidth);
        if (xPos > -charWidth && xPos < 16) {
            if (useLargeFont) {
                drawCharLarge(leds, currentText[i], xPos, 4); // Center vertically for 8x8 font
            } else {
                drawChar(leds, currentText[i], xPos, 4); // Center vertically for 5x7 font
            }
        }
    }
}

void setupTypePattern(AsyncWebServer* server) {
    server->on("/type", HTTP_GET, [](AsyncWebServerRequest *request) {
        String html = R"rawliteral(
<!DOCTYPE html>
<html>
<head>
    <title>PixelBoard Text</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #282c34;
            color: #ffffff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .toolbar {
            background: #3b3f47;
            padding: 10px 20px;
            border-bottom: 1px solid #61dafb;
            display: flex;
            align-items: center;
            gap: 20px;
        }
        .input-group {
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 1;
        }
        input[type="text"] {
            flex: 1;
            padding: 8px;
            border: 1px solid #61dafb;
            background: #282c34;
            color: #ffffff;
            border-radius: 4px;
            font-size: 16px;
        }
        .controls-group {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .font-selection {
            display: flex;
            gap: 5px;
        }
        .font-btn {
            background-color: #282c34;
            color: #61dafb;
            border: 1px solid #61dafb;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }
        .font-btn.active {
            background-color: #61dafb;
            color: #282c34;
        }
        .color-selection {
            display: flex;
            gap: 5px;
        }
        .color-btn {
            width: 32px;
            height: 32px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: transform 0.2s;
        }
        .color-btn.active {
            transform: scale(1.1);
            box-shadow: 0 0 0 2px #61dafb;
        }
        .update-btn {
            background-color: #61dafb;
            color: #282c34;
            border: none;
            padding: 8px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }
        .update-btn:hover {
            background-color: #4fa8d3;
        }
        .preview-container {
            flex: 1;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #282c34;
        }
        .preview-grid {
            display: grid;
            grid-template-columns: repeat(16, 1fr);
            gap: 2px;
            padding: 20px;
            background: #3b3f47;
            border-radius: 10px;
            aspect-ratio: 1;
            width: min(80%, 600px);
        }
        .preview-pixel {
            aspect-ratio: 1;
            background: #282c34;
            border-radius: 2px;
            transition: background-color 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="toolbar">
        <div class="input-group">
            <input type="text" id="textInput" maxlength="50" placeholder="Enter text to display" value="HELLO">
        </div>
        <div class="controls-group">
            <div class="font-selection">
                <button class="font-btn active" data-size="small">Small</button>
                <button class="font-btn" data-size="large">Large</button>
            </div>
            <div class="color-selection">
                <button class="color-btn active" style="background-color: #ffffff" data-color="white"></button>
                <button class="color-btn" style="background-color: #ff4d4d" data-color="red"></button>
                <button class="color-btn" style="background-color: #4dff4d" data-color="green"></button>
                <button class="color-btn" style="background-color: #4d4dff" data-color="blue"></button>
                <button class="color-btn" style="background-color: #ffff4d" data-color="yellow"></button>
            </div>
            <button class="update-btn" onclick="updateText()">Update Display</button>
        </div>
    </div>
    
    <div class="preview-container">
        <div class="preview-grid" id="previewGrid"></div>
    </div>

    <script>
        let previewUpdateInterval;
        
        function createPreviewGrid() {
            const grid = document.getElementById('previewGrid');
            for (let i = 0; i < 256; i++) {
                const pixel = document.createElement('div');
                pixel.className = 'preview-pixel';
                pixel.id = 'pixel-' + i;
                grid.appendChild(pixel);
            }
        }

        function updatePreview() {
            fetch('/pixelStatus')
                .then(response => response.arrayBuffer())
                .then(buffer => {
                    const pixels = new Uint8Array(buffer);
                    for (let i = 0; i < 256; i++) {
                        const baseIndex = i * 3;
                        const r = pixels[baseIndex];
                        const g = pixels[baseIndex + 1];
                        const b = pixels[baseIndex + 2];
                        
                        const pixelElement = document.getElementById('pixel-' + i);
                        if (pixelElement) {
                            pixelElement.style.backgroundColor = `rgb(${r},${g},${b})`;
                        }
                    }
                })
                .catch(error => console.error('Error updating preview:', error));
        }

        function updateText() {
            let text = document.getElementById('textInput').value.toUpperCase();
            if (text.length === 0) {
                alert('Please enter some text');
                return;
            }
            
            let activeColor = document.querySelector('.color-btn.active').dataset.color;
            let fontSize = document.querySelector('.font-btn.active').dataset.size;
            
            fetch(`/updatetext?text=${encodeURIComponent(text)}&color=${activeColor}&font=${fontSize}`)
                .then(response => response.text())
                .then(data => {
                    updatePreview(); // Update preview after text change
                });
        }

        document.querySelectorAll('.color-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            });
        });

        document.querySelectorAll('.font-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.font-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            });
        });

        // Add keyboard shortcut for Enter key
        document.getElementById('textInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                updateText();
            }
        });

        // Start periodic preview updates
        function startPreviewUpdates() {
            createPreviewGrid(); // Create the grid first
            updatePreview(); // Initial update
            previewUpdateInterval = setInterval(updatePreview, 100); // Update every 100ms
        }

        // Initialize preview on page load
        document.addEventListener('DOMContentLoaded', function() {
            startPreviewUpdates();
            // Set initial text
            updateText();
        });

        // Clean up interval when page is unloaded
        window.addEventListener('unload', function() {
            if (previewUpdateInterval) {
                clearInterval(previewUpdateInterval);
            }
        });
    </script>
</body>
</html>
)rawliteral";
        request->send(200, "text/html", html);
    });

    // Handler for updating the text
    server->on("/updatetext", HTTP_GET, [](AsyncWebServerRequest *request) {
        if (request->hasParam("text") && request->hasParam("color") && request->hasParam("font")) {
            String newText = request->getParam("text")->value();
            String color = request->getParam("color")->value();
            String fontSize = request->getParam("font")->value();
            
            // Update text
            currentText = newText;
            
            // Update color
            if (color == "red") textColor = CRGB::Red;
            else if (color == "green") textColor = CRGB::Green;
            else if (color == "blue") textColor = CRGB::Blue;
            else if (color == "yellow") textColor = CRGB::Yellow;
            else textColor = CRGB::White;
            
            // Update font size
            useLargeFont = (fontSize == "large");
            
            // Reset scroll position
            scrollPosition = -16;
            
            request->send(200, "text/plain", "Text updated");
        } else {
            request->send(400, "text/plain", "Missing parameters");
        }
    });
} 